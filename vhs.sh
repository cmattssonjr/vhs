#!/bin/bash
#
# This script requires TUI : https://github.com/sri-arjuna/tui
#
#
#	File:		/home/sea/.local/bin/vhs
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU Lesser General Public License (LGPL)
#	Created:	2014.05.18
#	Changed:	2014.05.29
	script_version=0.5.2
	TITLE="Video Handler Script by sea"
#	Description:	All in one movie handler, wrapper for ffmpeg
#			Simplyfied commands for easy use
#
#			It should encode a DVD with your prefered language only - when called from terminal,
#			but let you choose which languages, when your prefered langauge is not found.
#
#			Easy mass re-code files as it takes each file's name as replaces its container extension for the output.
#			If that new name exists, it numbers it incremently, so you cannot delete your input file by accident (from the script
#
#	Resources:	http://ffmpeg.org/index.html
#			https://wiki.archlinux.org/index.php/FFmpeg
#			https://support.google.com/youtube/answer/1722171?hl=en&ref_topic=2888648
#
#
#	Check if TUI is installed...
#
	S=/etc/profile.d/tui.sh
	if [[ ! -f $S ]]
	then 	[[ 0 -eq $UID ]] || \
			( printf "\n#\n#\tPlease restart the script as root to install TUI (Text User Interface).\n#\n#\n" ; exit 1 )
		git clone https://github.com/sri-arjuna/tui.git /tmp/tui.inst
    		sh /tmp/tui.inst/install.sh || \
    			(printf "\n#\n#\tPlease report this issue.\n#\n#\n";exit 1)
    	fi
    	source $S
#
#	Script Environment
#
	ME="${0##*/}"				# Basename of $0
	ME="${ME/.sh/}"				# Cut off .sh extension
	#ME_DIR="${0/${0##/*/}}"			# Dirname of $0
	CONFIG="$HOME/.config/$ME/$ME.conf"	# Configuration file
	LIST_FILE="${CONFIG:0:(-4)}list"	# Contains lists of codecs, formats
	LOG="${CONFIG:0:(-4)}log" 		#-$(date +'%T')	# If a daily log is prefered
	TMP="${CONFIG:0:(-4)}tmp"
	CONTAINER="$(dirname $CONFIG)/containers"
	sleep_between=3
	[[ -f "$CONFIG" ]] && container=$(tui-value-get "$CONFIG" "container")
#
#	Help text
#
	help_text="
$ME ($script_version)
${TITLE^}
Usage: 		$ME [options] [arguments]
Examples:	$ME -b a128 -b v512 filename	| Encode file with audio bitrate of 128k and video bitrate of 512k
		$ME -Cvwe webm *ogg		| Fake encodes all files ending with ogg as webm, 
						+ optimized to be played in a browser/stream, while beeing verbose
		$ME filename			| Encodes a file
		$ME -DC filename		| Fake encode a DVD
		$ME -s				| Captures screen
		$ME -W				| Captures webcam
Where options are:
	-h(elp) 			This screen
	-b(itrate)	[av]ARG		Set Bitrate to ARG kilobytes, use either 'a' or 'v' to define audio or video bitrate
	-B(itrate)			Use bitrates (av) from configuration
	-C(opy)				Just copy streams, fake convert
	-c(odec)	[av]ARG		Set codec to ARG for audio or video
	-e(xtension)	ARG		Use this container (ARG) instead of \"$container\"
	-L(OG)				Show the log file
	-Q(uality)	ARG		This is ment to use with -D.
					One of: CLIP DVD BR HD
					CLIP=	640x480
					DVD=	720x576
					BR=	1280x720
					HD=	1920x1080
	-s(creen)			Records the fullscreen desktop
	-S(etup)			Shows the setup dialog
	-v(erbose)			Displays encode data from ffmpeg
	-w(eb)				Optimizes for web usage
(BETA)	-W(ebcam)			Encodes from webcam

-- NON-FUNCTIONAL ??
	-D(VD)				Encode from DVD


Info:
------------------------------------------------------
After installing codecs, drivers or plug in of webcam,
it is highy recomended to update the list file.
You can do so by entering the Setup dialog: $ME -S
and select 'UpdateLists'.

Recording from webcam does a terminal lockup on my system.
However, forum users confirmed that the default example
command works, thus, i'm currently let you use that one,
rather than the command generated by the script.


Files:		
------------------------------------------------------
Script:		$0
Config:		$CONFIG
Containers:	$CONTAINER
Lists:		$LIST_FILE
Log:		$LOG

"
#
#	Variables
#
	REQUIRES="ffmpeg v4l-utils"		# This is absolutly required 
	REQUIRED=""				# Will be filled, if missing
#
#	Defaults, do not change
#
	doCopy=false
	doQuality=false
	show_menu=false
	BIT_VIDEO=768
	BIT_AUDIO=192	# Equals ~1 MB in total
	override_video_bit=false
	override_audio_bit=false
	override_video_codec=false
	override_audio_codec=false
	override_container=false
	extra=""
	verbose=" -v quiet"	# -hide-banner
	web=""
	mode="file"
	QUALITY=""
#
#	Functions
#
	doLog() { # "MESSAGE STRING"
	# Prints: Time & "Message STRING"
	# See 'tui-log -h' for more info
		tui-log -t "$LOG" "$1"
	}
	GetQuality() { # ABR
	# This will override the sources specifications
	#
		[[ "-h" = "$1" || "list" = "$1" ]] && \
			printf "CLIP DVD BR HD WEBCAM WEBCAMSD WEBCAMHD"
		WH=( $(xrandr|grep \*|sed s,x,' ',g|awk '{print $1" "$2}') )
		vbits=$[ ${WH[0]} / 2  ]
		
		# VAR	WIDTH 	HEIGHT 	A-BIT 	V-BIT
		SCREEN="${WH[0]} ${WH[1]} 128 $vbits"
		CLIP="	640	480	112	384"
		DVD="	720	576	128	512"
		BR="	1280	720	256	1024"
		HD="	1920	1080	256	1536"
		
		out=$(  eval echo "\$$1"  )
		printf "$out"|awk '{print "-s "$1"x"$2" -b:a "$3" -b:v "$4}'
	}
	#GetQuality SCREEN
	genFilename() { # Filename container
	# Parses for file extension and compares with new container
	# If identical, add a number to avoid overwriting sourcefile.
		video="$1"
		container="$2"
		for ext in $(printf "$video"|sed s,'\.',' ',g);do printf "" > /dev/zero;done
		if [[ $ext = $container ]]
		then 	# new file name would be the same
			name="${video/$ext/}"
			N=0
			while [[ -f "$name$N.$container" ]] ; do ((N++));done
			outputfile="$name$N.$container"
			doLog "Output: Has same extension, incrementing to \"$outputfile\""
		else 	outputfile="${video/$ext/}$container"
			doLog "Output: \"$outputfile\""
		fi
		printf "$outputfile"
	}
	hasMultipleStreams() { # [/path/to/]filename
	# If more than one audio stream is found, returns success (0)
	#
		touch "$TMP"
		ffmpeg -psnr -i "$1"  2>&1 | grep Stream |grep Audio > "$TMP"
		lines=$(cat "$TMP"|wc -l)
		[[ $lines -gt 1 ]] && \
			doLog "Audio: Multiple streams found" && \
			return 0			
		return 1
	}
	hasDTS() { # filename
	#
	#
		touch "$TMP.dts"
		grep -i dts "$TMP" > "$TMP.dts"
		lines=$(cat "$TMP.dts"|wc -l)
		[[ $lines -gt 1 ]] && \
			doLog "Audio: DTS encoding found" && \
			return 0			
		return 1
	}
	hasLang() { # filename
	#
	#
		num=$(grep "($lang)" "$TMP"|wc -l)
		[[ ! -z $num ]] && \
			doLog "Audio: Found $num entry for \"$lang\"" && \
			return 0			
		return 1
	}
	WriteContainers() { # 
	# Writes several container files and their default / suggested values
	#
		header="# $ME ($script_version) - Container definition"
		[[ -d "$CONTAINER" ]] || mkdir -p "$CONTAINER"
		cd "$CONTAINER"
		for entry in avi mp4 mkv ogg webm;do
		case entry in
		avi)	ca=mpeg2video 	# Codec Audio
			cv=mp3		# Codec Video
			ce=false	# Codec extra
			fe=true 	# File extra (audio codec dependant)
			ba=	# Bitrate Audio
			bv=	# Bitrate Video
			q=CLIP		# Set container quality
			;;
		dvd)	ca=mpeg2video 	# Codec Audio
			cv=mp3		# Codec Video
			ce=""		# Codec extra
			fe=""		# File extra (audio codec dependant)
			ba=""	# Bitrate Audio
			bv=""	# Bitrate Video
			q=DVD		# Set container quality
			;;
		mp4)	ca=aac		# Codec Audio
			cv=libx264	# Codec Video
			ce=true		# Codec extra
			fe=true		# File extra (audio codec dependant)
			ba=""	# Bitrate Audio
			bv=""	# Bitrate Video
			q=BR		# Set container quality
			;;
		mkv)	ca=ac3		# Codec Audio
			cv=libx264	# Codec Video
			ce=false	# Codec extra
			fe=false	# File extra (audio codec dependant)
			ba=""	# Bitrate Audio
			bv=""	# Bitrate Video
			q=HD	# Set container quality
			;;
		ogg)	ca=vorbis	# Codec Audio
			cv=theora	# Codec Video
			ce=true		# Codec extra
			fe=true			# File extra (audio codec dependant)
			ba=""	# Bitrate Audio
			bv=""	# Bitrate Video
			q=DVD	# Set container quality
			;;
		webm)	ca=vorbis	# Codec Audio
			cv=vp9		# Codec Video
			ce=true		# Codec extra
			fe=true		# File extra (audio codec dependant)
			ba=""	# Bitrate Audio
			bv=""	# Bitrate Video
			q=BR		# Set container quality
			;;
		# blob)	ca=	# Codec Audio
		#	cv=	# Codec Video
		#	ce=""	# Codec extra
		#	fe=""	# File extra (audio codec dependant)
		#	ba=""	# Bitrate Audio
		#	bv=""	# Bitrate Video
		#	q=CLIP	# Set container quality
		#	;;
		esac
		touch $entry
		printf "$header\ncontainer=$entry\naudio_codec=$ca\nvideo_codec=$cv\nquality=$q\codec_extra=$ce\nfile_extra=$fe" > $entry
		doLog "Container: Create $entry definitions (defaults)"
		done
	}
	UpdateLists() { #
	# Retrieve values for later use
	# Run again after installing new codecs or drivers
		[[ -f "$LIST_FILE" ]] || touch "$LIST_FILE"
		tui-title "Generating a list file"
		tui-progress "Retrieve raw data..."
		ffmpeg $verbose -codecs | grep \ DE > "$TUI_TEMP_FILE"
		sleep 0.3
		
		tui-progress "Saving Audio-codecs"
		audio_raw=$(grep DEA "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		audio=""
		for a in $audio_raw;do audio+=" $a";done
		printf "codecs_audio=\"$audio\"\n" > "$LIST_FILE"
		doLog "Lists : Updated Audio-Codecs"
		sleep 0.3
		
		tui-progress "Saving Video-codecs"
		video_raw=$(grep DEV "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		video=""
		for v in $video_raw;do video+=" $v";done
		printf "codecs_video=\"$video\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Video-Codecs"
		sleep 0.3
		
		tui-progress "Saving Subtitle-codecs"
		subtitle_raw=$(grep DES "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		subtitle=""
		for s in $subtitle_raw;do subtitle+=" $s";done
		printf "codecs_subtitle=\"$subtitle\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Subtitle-Codecs"
		sleep 0.3
		
		tui-progress "Saving Codecs-Format"
		ffmpeg $verbose -formats > "$TUI_TEMP_FILE"
		formats_raw=$(grep DE "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		formats=""
		for f in $formats_raw;do formats+=" $f";done
		printf "codecs_formats=\"$formats\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Codecs-Format"
		sleep 0.3
		
		if [[ ! "" = "$(ls /dev/video0)" ]]
		then 	#v4l2-ctl cant handle video1 .. ??
			tui-progress "Saving WebCam-Formats"
			# webcam_formats="$(printf $(v4l2-ctl --list-formats-ext|grep Siz|awk '{print $3}'|sort))"
			webcam_formats=""
			wf="$(v4l2-ctl --list-formats-ext|grep $webcam_fps -B4 |grep Siz|awk '{print $3}'|sort)"
			for w in $wf;do webcam_formats+=" $w";done
			printf "webcam_formats=\"$webcam_formats\"\n" >> "$LIST_FILE"
			doLog "Lists : Updated WebCam-Format"
			sleep 0.3
		
			tui-progress "Saving WebCam-frames"
			# webcam_formats="$(printf $(v4l2-ctl --list-formats-ext|grep Siz|awk '{print $3}'|sort))"
			webcam_frames=""
			wf="$( v4l2-ctl --list-formats-ext|grep Siz -A6|awk '{print $4}')"
			C=0
			for w in $wf;do webcam_frames+=" ${w/(/}";((C++));[[ $C -ge 6 ]] && break;done
			printf "webcam_frames=\"$webcam_frames\"\n"|sed s,"\.000","",g >> "$LIST_FILE"
			doLog "Lists : Updated WebCam-Frames"
			sleep 0.3
		fi
		
		tui-status $? "Updated $LIST_FILE"
	}
	#source "$LIST_FILE" || UpdateLists
	MenuSetup() { # 
	# Configures the variables/files used by the script
	# 
	#
	#	Variables
	#
		source "$LIST_FILE" || UpdateLists
		[[ -f "$CONFIG" ]] || cat > "$CONFIG" << EOF
# $CONFIG, generated by $ME ($script_version)

# Available containers:
# -> avi mkv mp4 ogg webm
container=webm

# Audio bitrate suggested range (values examples): 72 96 128 144 192 256
BIT_AUDIO=$BIT_AUDIO

# Video bitrate suggested range (value examples): 128 256 512 768 1024 1280 1536 1920
BIT_VIDEO=$BIT_VIDEO

# See ffmpeg output for your language
lang=eng

# If DTS is found, to how many channels shall it 'downgrade'?
# Range::  1) Mono, 2) Stereo, [3-5]) dunno, 6) 5.1
channels=2

# This is a default value that should work on most webcams
webcam_res="640x480"
webcam_fps=25
EOF
	#
	#	Setup menu
	#
		VARS=$(tui-value-get -l "$CONFIG"|grep -v req)
		tui-echo "Which variable to change?"
		select var in Back UpdateLists $VARS;do
			case $var in
			Back)		break	;;
			UpdateLists)	$var 	;;
			*)	val=$(tui-value-get "$CONFIG" "$var")
				tui-echo "${var^} is set to:" "$val"
				if tui-yesno "Change this value?"
				then	case $var in
					container)	tui-echo "Please select a new one:"
							select newval in $(cd "$(dirname $CONFIG)/containers";ls);do break;done
							;;
					channnels)	tui-echo "Please select a new amount:"
							select newval in $(seq 1 1 6);do break;done
							;;
					webcam_res)	tui-echo "Please select the new resolution:"
							select newval in $webcam_formats;do break;done
							;;
					webcam_fps)	tui-echo "Please select the new framerate:"
							select newval in $webcam_frames;do break;done
							;;
					*)		newval=$(tui-read "Please type new value:")
							;;
					esac
					msg="Changed \"$var\" from \"$val\" to \"$newval\""
					tui-value-set "$CONFIG" "$var" "$newval"
					tui-status $? "$msg" && \
						doLog "$msg" || \
						doLog "Failed to c$(printf ${msg:1}|sed s,ged,ge,g)"
				fi
			;;
			esac
			tui-echo "Press [ENTER] to see the menu:" "$INFO"
		done
	}
#
#	Environment checks
#
	# This is optimized for a one-time setup
	[[ ! -f "$CONFIG" ]] && \
		mkdir -p "$(dirname $CONFIG)" && \
		doLog "Setup : First config" && \
		tui-echo "Entering first time setup." "$SKIP" && \
		sleep 1 && \
		MenuSetup
	source "$CONFIG" || \
		( doLog "Failed to load: $CONFIG" ; tui-status 1 "Failed to load: $CONFIG" )
	[[ -d "$(dirname $CONFIG)/containers" ]] || WriteContainers
#
#	Catching Arguments
#
	tui-log -e "$LOG" "\r---- New call $$ ----"
	while getopts "aBb:c:CDe:hLSsQ:vwW" opt
	do 	case $opt in
		b)	case "${OPTARG:0:1}" in
			a)	override_audio_bit=true
				doLog "Options: Override audio bitrate ($BIT_AUDIO) with ${OPTARG:1}"
				BIT_AUDIO="${OPTARG:1}"
				;;
			v)	override_video_bit=true
				doLog "Options: Override video bitrate ($BIT_VIDEO) with ${OPTARG:1}"
				BIT_VIDEO="${OPTARG:1}"
				;;
			*)	tui-status 1 "You did not define whether its audio or video: -$opt [av]$OPTARG"
				exit 1
				;;
			esac
			;;
		B)	override_audio_bit=true
			override_video_bit=true
			BIT_AUDIO=$(tui-value-get "$CONFIG" "BIT_AUDIO")
			BIT_VIDEO=$(tui-value-get "$CONFIG" "BIT_VIDEO")
			doLog "Options: Using bitrates from $CONFIG (A:$BIT_AUDIO V:$BIT_VIDEO )"
			;;
		c)	case "${OPTARG:0:1}" in
			a)	override_audio_codec=true
				doLog "Options: Override audio bitrate ($audio_codec) with ${OPTARG:1}"
				audio_codec="${OPTARG:1}"
				;;
			v)	override_video_codec=true
				doLog "Options: Override video bitrate ($video_codec) with ${OPTARG:1}"
				video_codec="${OPTARG:1}"
				;;
			*)	tui-status 1 "You did not define whether its audio or video: -$opt [av]$OPTARG"
				exit 1
				;;
			esac
			;;
		C)	doCopy=true
			override_video_codec=true
			override_audio_codec=true
			video_codec=copy
			audio_codec=copy
			doLog "Options: Just copy streams, no encoding"
			;;
		D)	mode=dvd
			tempdata=( $(ls /run/media/$USER))
			[[ "${#tempdata[@]}" -ge 2 ]] && \
				tui-echo "Please select which entry is the DVD:" && \
				select name in "${tempdata[@]}";do break;done || \
				name="$(printf $tempdata)"
			SCREEN_OF=$(genFilename "DVD-$tempdata.$container" $container )
			SCREENER=DVD
			override_container=true
			;;
		e)	#doLog "Options: Set container to $OPTARG"
			override_container=true
			doLog "Options: Overwrite \"$container\" with \"$OPTARG\""
			container="$OPTARG"
			;;
		h)	printf "$help_text"
			exit $RET_HELP
			;;
		L)	less "$LOG"	
			exit $RET_DONE
			;;
		Q)	QUALITY=$(GetQuality "$OPTARG")
			source "$CONTAINER/$container"
			doQuality=true	;;
		v)	doLog "Options: Be verbose!"
			verbose="-v info"		;;
		w)	doLog "Options: Optimize for web usage."
			web="-movflags faststart"	;;
		W)	mode=webcam
			SCREEN_OF=$(genFilename "webcam-out.$container" $container )
			SCREENER=webcam
			override_container=true
			;;
		s)	mode=screen
			SCREEN_OF=$(genFilename "screen-out.$container" $container )
			SCREENER=screen
			override_container=true
			;;
		S)	MenuSetup
			exit 0	;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS=(${*})			# Remaining arguments
	ARGS_COUNT=${#ARGS[@]}		# Amount of remaining
#
#	Install missing packages
#
	doLog "Mode: $mode"
	tui-progress -ri movies-req " "
	if [[ ! true = "$req_inst" ]]
	then 	doLog "Req : Checking for installed packages"
		for R in $REQUIRES;do
			tui-progress -i movies-req -m ${#REQUIRES} "Check requirements: $R"
			rpm -qa $F > /dev/zero || ( REQUIRED+=" $R" ; doLog "Req : Missing $R" )
		done
	fi
	if [[ ! " " = "$(printf "${REQUIRED} ")" ]]
	then 	tui-title "Installing missing packages"
		doLog "Req : Installing missing packages: $REQUIRED"
		sudo yum install -y $REQUIRED && \
			printf "req_inst=true\n" >> "$CONFIG"
		tui-status $? "Installed: $REQUIRED"
		[[ 0 -eq $? ]] && \
			ret_info="succeeded" || \
			ret_info="failed"
		doLog "Req: Installation of $REQUIRED $ret_info"
	else 	[[ ! true = "$req_inst" ]] && \
			printf "req_inst=true\n" >> "$CONFIG" && \
			doLog "Req : All required packages already installed"
	fi
#
#	Display & Action
#
	tui-header "$ME ($script_version)" "$(date +'%F %T')"
	tui-title "$TITLE"
#
#	Do this for every supplied argument
#
	#if [[ ! screen = "$mode" ]] && [[ ! webcam = "$mode" ]] && [[ ! dvd = "$mode" ]] && [[ -z "$1" ]]
	#then 	show_menu=true
	#fi
	[[ file = "$mode" ]] && \
		[[ -z "$1" ]] && \
		show_menu=true
#
#	get 'best' codecs for $container, unless override is true
#	
	[[ $override_container = true ]] && \
		doLog "Options: Set to $container" || \
		doLog "Container: $container (default)"
	if [[ true = $doCopy ]]
	then 	doLog "Options: Just copy streams..."
	else 	# 'doLog' if override is active
		[[ true = $override_audio_codec ]] && doLog "Options: Audio codec is overwritten"
		[[ true = $override_video_codec ]] && doLog "Options: Video codec is overwritten"
		[[ true = $override_audio_bit ]] && doLog "Options: Audio bitrate is overwritten"
		[[ true = $override_video_bit ]] && doLog "Options: Video bitrate is overwritten"
		# Set default variables if override is false (not true)
		case $container in
		webm)		# Good compression, FREE standard
				[[ true = $override_video_codec ]] || video_codec=vp9
				[[ true = $override_audio_codec ]] || audio_codec=vorbis
				[[ true = $override_audio_codec ]] || extra+=" -strict -2"
				extra+=" -preset fast"
				F="-f $container"
				;;
		mkv)		[[ true = $override_video_codec ]] || video_codec=libx264
				[[ true = $override_audio_codec ]] || audio_codec=ac3
				;;
		mp4)		# Very fast
				[[ true = $override_video_codec ]] || video_codec=libx264
				[[ true = $override_audio_codec ]] || audio_codec=aac
				[[ true = $override_audio_codec ]] || extra+=" -strict -2"
				F="-f $container"
				;;
		ogg)		# Horrible video :(
				[[ true = $override_video_codec ]] || video_codec=theora
				[[ true = $override_audio_codec ]] || audio_codec=vorbis
				[[ true = $override_audio_codec ]] || extra+=" -strict -2"
				F="-f $container"
				;;
		avi)		# Quick, but large .. 
				[[ true = $override_video_codec ]] || video_codec=mpeg2video 
				[[ true = $override_audio_codec ]] || audio_codec=mp3
				F="-f $container"
				;;
		*)		tui-status 1 "Invalid container: $container..." 
				exit 1
				;;
		esac
	fi
#
#	Show menu or go for the loop of files
#
	if [[ $show_menu = false ]]
	then 	for video in "${@}" $SCREENER;do
		#
		#	New file
		#
			doLog "----- $video -----"
			tui-title "Input: $video"
			case $mode in
			screen|dvd)	OF="$SCREEN_OF" ;;
			*)	#
				#	Verify Inputfile exists and outputfile has not the same name
				#	
					[[ -f "$video" ]] && \
						tui-status $? "Inputfile ($video) checked." && \
						doLog "Input Found: $video" || \
						( tui-status $? "Input ($video) not found!" ; doLog "Input Missing: $video" ; exit 1 )
					# Output File
					OF=$(genFilename "${video}" "$container")
					# OF="$(pwd)/$OF"
				;;
			esac
		#
		#	Get audio stream
		#
			if hasMultipleStreams "$video"		# This also creates the $TMP file
			then	tui-title "Available audio streams"
				audio_streams="-map 0:0"	# Hardcode video stream ;)				
				lang=$(tui-value-get "$CONFIG" "lang")
				CHANNELS="-ac "$(tui-value-get "$CONFIG" "channels")
				while read line;do tui-echo "$line";done<"$TMP"
				#tui-echo
				if hasLang "$video"
				then 	# Default langauge found
					msg="Auto-selected \"$lang\""
					check=$(grep -n "($lang)" "$TMP"|sed s,":"," ",g|awk '{print $1}')
					tui-status $? "$msg" && doLog "Audio: $msg"
					for c in $check;do audio_streams+=" -map 0:$c";done
					hasDTS "$video" && doChannels=true
				else	# No default language set or found
					# Let the user decide
					tui-echo "Select which streams you want to add (multiple are possible):"
					select stream in $(seq 1 1 $lines) Done;do
					case $stream in
					Done)	break	;;
					*)	printf "$stream"|grep [0-9] -q && \
							audio_streams+=" -map 0:$stream"	|| \
							tui-status 1 "Invalid input, try again."
						;;
					esac
					done
				fi
				hasDTS "$video" && audio_streams+=" $CHANNELS"
				doLog "Audio: audio_streams=\"$audio_streams\""
			fi
			
			skip=false	# Init var
			
			if [[ -f "$OF" ]]
			then 	if tui-yesno "Outputfile ($OF) exists, overwrite it?"
				then 	rm -f "$OF"
				else	skip=true
				fi
			fi
			
			if [[ false = $skip ]] 
			then 
			#
			#	Generate the command
			#
				[[ true = $override_audio_bit ]] && bits+=" -b:a ${BIT_AUDIO}K"
				[[ true = $override_video_bit ]] && bits+=" -b:v ${BIT_VIDEO}K "
				[[ true = $doQuality ]] && bits="$QUALITY"	# Overwrite 
				
				[[ -z $mode ]] && mode="file"
				doLog "Type: Encode $mode"
				
				msg="Begin:"
				case "$mode" in
				screen)		# Done
						msg+=" Capturing"
						tui-status $RET_INFO "Press 'q' to stop recording..."
						[[ -z $container ]] && container=mkv
						[[ -z $video_codec ]] && video_codec=ffvhuff 
						[[ -z $audio_codec ]] && audio_codec=flac
						[[ -z $DISPLAY ]] && DISPLAY=":0.0"	# Should not happen, setting to default
						screen=" -f x11grab -video_size  $(xrandr|grep \*|awk '{print $1}') -i $DISPLAY -f alsa -i default -c:v $video_codec -c:a $audio_codec $bits"
						cmd="ffmpeg $verbose $screen $extra $web $F \"${SCREEN_OF}\""
						;;
				webcam)		# Done ?? dont work for me, but seems to for others
						msg+=" Capturing"
						tui-status $RET_INFO "Press 'q' to stop recording..."
						srcs=($(ls /dev/video*))
						case ${#srcs[@]} in
						1)	echo jup ;;
						esac
						if [[ "$(printf $srcs)" = "$(printf $srcs|awk '{print $1}')" ]]
						then 	input_video="$srcs"
						else	tui-echo "Please select the video source to use:"
							select input_video in $srcs;do break;done
						fi
						
						tui-status $RET_INFO "Standard is said to be working, sea's should - but might not, please report"
						select webcam_mode in standard sea;do
						case $webcam_mode in
						standard)	# Forum users said this line works
								doLog "Overwrite already generated name, for 'example' code.. "
								OF="$(genFilename output.mpg mpg)"
								cmd="ffmpeg $verbose -f v4l2 -s $webcam_res -i /dev/video0 $F \"${OF}\""
								;;
						sea)		# Non working ??
								OF="$SCREEN_OF"
								cmd="ffmpeg $verbose -f v4l2 -r $webcam_fps -s $webcam_res -i $input_video -f alsa -i default -acodec $audio_codec -vcodec $video_codec $extra $F \"${OF}\""
								;;
						esac
						doLog "WebCam: Using $webcam_mode command"
						break
						done
						;;
				dvd)		# TODO
						msg+=" Encoding"
						# -vf yadif
						#  cat f0.VOB f1.VOB f2.VOB | ffmpeg -i - out.mp2
						dvd_base="/run/media/$USER/$name"
						input_vobs=$(find $dvd_base|grep -i vob)
						vobs=""
						vob_list=""
						total=0
						for v in $input_vobs;do 
							if [[ $(ls -l $v|awk '{print $5}') -gt 700000000 ]]
							then 	vobs+=" -i ${v##*/}"
								vob_list+=" ${v##*/}"
								((total++))
							fi
						done
						
						# If tempdir exists, good chances files were already copied
						dvd_tmp="$HOME/.cache/$name"
						dvd_reuse=nothing
						errors=0
						
						[[ -d "$dvd_tmp" ]] && \
						 	tui-yesno "$dvd_tmp already exists, reuse it?" && \
							dvd_reuse=true || \
							dvd_reuse=false
					
						# Create tempdir to copy vob files into
						if [[ ! true = $dvd_reuse ]]
						then 	mkdir -p "$dvd_tmp"
							doLog "DVD: Copy vobs to \"$dvd_tmp\""
							tui-echo "Copy vob files to \"$dvd_tmp\", this may take a while..." "$WORK"
							C=1
							for vob in $vob_list;do
								lbl="${vob##*/}"
								MSG1="Copy $lbl ($C / $total)"
								MSG2="Copied $lbl ($C / $total)"
								 # 2>&1
								printf "cp -n \"$dvd_base/VIDEO_TS/$vob\" \"$dvd_tmp\"" > "$TMP"
								tui-bgjob -f "$dvd_tmp/$vob" "$TMP" "$MSG1" "$MSG2"
								if [[ 0 -eq $? ]] #"Copied $lbl"
								then 	doLog "DVD: ($C/$total) Successfully copied $lbl"
								else 	doLog "DVD: ($C/$total) Failed copy $lbl"
									((errors++))
								fi
								((C++))
							done
						fi
						tui-echo
						[[ $errors -ge 1 ]] && \
							tui-yesno "There were $errors errors, would you rather try to encode straight from the disc?" && \
							cd "$dvd_base/VIDEO_TS" || \
							cd "$dvd_tmp"
						
						A="Attemp direct invoke of vobs"
						B="Truncate mux (cat)"
						C="ffmpeg dvd target"
						tui-echo "Please select a method:"
						select DVD_ENCODE in "$A" "$B" "$C";do
						case "$DVD_ENCODE" in
						"$A")	cd "$dvd_base/VIDEO_TS"
							cmd="ffmpeg $verbose -i $vob_list -acodec $audio_codec -vcodec $video_codec $extra  $F \"$HOME/${OF}\""
							break
							;;
						"$B")	cmd="cat $vob_list|ffmpeg $verbose -acodec $audio_codec -vcodec $video_codec $extra  $F \"$HOME/${OF}\""
							break
							;;
						"$C")	OF="$HOME/${OF}"
							cmd="ffmpeg $verbose $vobs -target film-dvd -q:a 0 -q:v 0 \"${OF}\""
							cmd="ffmpeg $verbose $vobs -target film-dvd -q:a 0 -q:v 0 $HOME/output.mpg"
							break
							;;
						esac
						#cmd="ffmpeg $verbose $vobs -target film-dvd -q:a 4 -q:v 4  -i /dev/cdrom  \"${OF}\""
						#cmd="ffmpeg $verbose $vobs -target film-dvd   \"${OF}\""
						#cmd="ffmpeg $verbose -i $vob_list -acodec $audio_codec -vcodec $video_codec $extra   \"${OF}\""
						done
						doLog "DVD: Using \"$DVD_ENCODE\" command"
						;;
				file)		# Done
						cmd="ffmpeg $verbose -i \"${video}\" $web $extra $bits -vcodec $video_codec -acodec $audio_codec $audio_streams $F \"${OF}\""
						msg+=" Converting"
						;;
				esac
				
				msg+=" from \"$video\" to \"$OF\""
				tui-printf "$msg" "$WORK"
				printf "$cmd" > "$TMP"
				doLog "$msg"
				doLog "Command: $cmd"
			#
			#	Execute the command
			#
				STR2="Converted \"$video\" to \"$OF\""
				STR1="Converting \"$video\" to \"$OF\""
				str="\$(ls -lh \"$OF\"|awk '{print \$5}')"
				if [[ $mode = "file" ]] || [[ $mode = "dvd" ]]
				then 	tui-bgjob -f "$OF" "$TMP" "$STR1" "$STR2"
					RET=$?
				else	sh "$TMP"
					tui-status $? "$STR2"
					RET=$?
				fi
			#
			#	Log if encode was successfull or not
			#	
				[[ 0 -eq $RET ]] && \
					ret_info="successfully (ret: $RET) \"$OF\"" || \
					ret_info="a faulty (ret: $RET) \"$video\""
				doLog "End: Encoded $ret_info "
				sleep $sleep_between
			else	msg="Skiped: $video"
				doLog "$msg"
				tui-status $RET_SKIP "$msg"
			fi
		done	
		exit $?
	else	# Show menu
		# after 'generating' the basic variables
		tui-status $RET_INFO "See $ME -h for help"
		tui-status 1 "Menu is not supported yet" || exit $?
		tui-echo "Selected input:" "$video"
		# Verify output filename
		outputfile=$(genFilename "$video" "$container")
		tui-echo "What is the outputs name? (leave empty for: $outputfile)"
		newname=$(tui-read "Type the name:")
		[[ -z "$newname" ]] && newname="$outputfile"
		# If user has not passed file container / extension
		printf "$newname"|grep -q $container || newname+=".$container"
	fi
exit
